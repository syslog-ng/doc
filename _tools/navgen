#!/bin/bash

BASE_INDENT="  "
INDEX_FILE_PATTERNS="^(index\.md|README\.md)$"
FRONT_MATTER_HEADER_FOOTER="---"

USE_INDEX_FILE_FOR_FOLDER_LINKS="yes"
REMOVE_UNDERLINE_FROM_DOC_DIR_NAMES="yes"


trim_trailing_slashes()
{
    local INPUT_STRING="$1"
    echo "${INPUT_STRING%/}"
}

print_entry()
{
	echo "${1}  - title: ${2}"
	echo "${1}    url: ${3}"
	if [ "$#" -eq 4 ]; then
		echo "${1}    ${4}"
	fi
}

check_directory_content()
{
    /bin/ls -1 -p "${1}" | grep -Ev "${INDEX_FILE_PATTERNS}" >/dev/null
}

add_file_entry () {
	local FILE_TITLE=$(read_file_title "${1}")
    local URL="${2}"
	
	[ -n "$FILE_TITLE" ] && TITLE="\"$FILE_TITLE\""

	print_entry "${INDENT}" "${TITLE}" "${URL}"
}

add_dir_entry()
{
	local EXCLUDED_FILES=("${1}/index.md" "${1}/README.md")
    local URL="${2}"
	local INDEX_FILE="index"

	for EXCLUDED_FILE in "${EXCLUDED_FILES[@]}"; do
		if [ -f "${EXCLUDED_FILE}" ]; then
			local DIR_TITLE=$(read_file_title "${EXCLUDED_FILE}")
            local BASE_NAME=$(basename "${EXCLUDED_FILE}")

            INDEX_FILE=${BASE_NAME%.*}
			[ -n "${DIR_TITLE}" ] && TITLE="\"${DIR_TITLE}\""
			break
		fi
	done

    [ "${USE_INDEX_FILE_FOR_FOLDER_LINKS}x" != "x" ] && URL="${URL}/${INDEX_FILE}"

	print_entry "${INDENT}" "${TITLE}" "${URL}" "subnav:${3}"
}

url_for_file()
{
    local ITEM_PATH="$1"
    local DIR="$2"
    local ITEM_NAME="$3"
    local RELATIVE_PATH=${DIR#${START_DIR}}
    [ "$RELATIVE_PATH" == "${DIR}" ] && RELATIVE_PATH=""
    local URL="${ROOT_DIR_NAME}${RELATIVE_PATH}/${ITEM_NAME%.md}"
    if [ -f "${ITEM_PATH}" ]; then
        local PERMALINK=$(read_file_permalink "${ITEM_PATH}")
        [ "${PERMALINK}x" != "x" ] && URL="${PERMALINK}"
    fi

    # Adding now the leaign / to support proper root references as well everywhere
    # links must be used via the markdown_link include (or with the '| relative_url' filter) that will handle this 
    echo "/${URL}"
}

generate_yaml()
{
    local DIR="$1"
    local INDENT="$2"
    
    for ITEM in $(/bin/ls -1 "${DIR}" | grep -Ev "${INDEX_FILE_PATTERNS}" | sort); do
        local ITEM_PATH="${DIR}/${ITEM}"
        local ITEM_NAME=$(basename "$ITEM")
        local TITLE="\"${ITEM_NAME}\""
        local URL=$(url_for_file "${ITEM_PATH}" "${DIR}" "${ITEM_NAME}")
        
        if [ -f "${ITEM_PATH}" ]; then
			add_file_entry "${ITEM_PATH}" "${URL}"
        elif [ -d "${ITEM_PATH}" ]; then
			add_dir_entry "${ITEM_PATH}" "${URL}" "" # "$(check_directory_content "$ITEM_PATH" || echo " true")"
			generate_yaml "${ITEM_PATH}" "${INDENT}${BASE_INDENT}"
        fi
    done
}

read_file_header_item()
{
    local FILE=$1
    shift
    local ITEMS_REGEXES=("$@")
    local DELIMITER_FOUND=false
    local TITLE=""
    
    while IFS= read -r LINE; do
        if [ "${LINE}" == "${FRONT_MATTER_HEADER_FOOTER}" ]; then
            if ${DELIMITER_FOUND}; then
                # Stop if front matter is finished
                break
            else
                DELIMITER_FOUND=true
            fi
        elif ${DELIMITER_FOUND}; then
            if [[ "${LINE}" =~ ${ITEMS_REGEXES[0]} ]]; then
                TITLE="${BASH_REMATCH[1]}"
                # Can break here, first patter always has the top precedence now
                break
            elif [ ${#ITEMS_REGEXES[@]} -gt 1 ] && [[ "${LINE}" =~ ${ITEMS_REGEXES[1]} ]]; then
                TITLE="${BASH_REMATCH[1]}"
                # Do not break here the order can be anything
            fi
        else
            # First line was not a front matter header
            break;
        fi
    done < "${FILE}"
    
    echo "${TITLE}"
}

read_file_id()
{
    read_file_header_item "$1" '^id: (.*)$'
}

read_file_title()
{
    read_file_header_item "$1" '^short_title: (.*)$' '^title: (.*)$'
}

read_file_permalink()
{
    read_file_header_item "$1" '^permalink: (.*)$'
}

add_warning_header ()
{
    local FILE=$1

    echo "# --------------------------------------" >> "${FILE}"
    echo "# This file is auto generated           " >> "${FILE}"
    echo "#      - DO NOT EDIT -                  " >> "${FILE}"
    echo "# Use the _tools/navgen script instead  " >> "${FILE}"
    echo "# --------------------------------------" >> "${FILE}"
    echo "" >> "${FILE}"
}

gen_navigation()
{    
    > "${OUTPUT_FILE}"
    add_warning_header "${OUTPUT_FILE}"

    for DOC_PROJECT_ITEM in $(find -L "${DOC_FOLDER}" -mindepth 1 -maxdepth 1 -type d | sort); do
        START_DIR=$(trim_trailing_slashes "${DOC_PROJECT_ITEM}")
        ROOT_DIR_NAME=$(basename "${START_DIR}")
        [ "${REMOVE_UNDERLINE_FROM_DOC_DIR_NAMES}x" != "x" ] && ROOT_DIR_NAME=${ROOT_DIR_NAME#_}

        echo "" >> "${OUTPUT_FILE}"
        echo "# ${ROOT_DIR_NAME}" >> "${OUTPUT_FILE}"
        echo "${ROOT_DIR_NAME}-nav:" >> "${OUTPUT_FILE}"

        # A bit cheating just to have the same formatting as for file URLs
        local URL=$(url_for_file "${ROOT_DIR_NAME}" "" "")
        add_dir_entry "${START_DIR}" "${URL}" "" >> "${OUTPUT_FILE}"
        generate_yaml "${START_DIR}" "" >> "${OUTPUT_FILE}"

        shift
    done
}

process_params()
{
    gen_navigation
    
    echo "YAML structure and page links have  been generated and saved to $OUTPUT_FILE"
}


# Check for the correct number of command-line parameters
if [ "$#" -lt 2 ]; then
    echo "Usage: $0 <doc_folder> <output_nav_file>"
    exit 1
fi

DOC_FOLDER="${1}"
OUTPUT_FILE="${2}"    

process_params "$@"
