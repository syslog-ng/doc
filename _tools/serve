#!/bin/bash

REF_FILE="./.reftime"
NAV_DATA_FILE="./_data/navigation.yml"
ALL_PARAMS=$@
WATCHER_PID=

start_dir_watcher() {
    echo -e "Starting dir watcher...\n"

    .vendor/bundle/ruby/3.3.0/gems/rb-fsevent-0.11.2/bin/fsevent_watch --format=otnetstring --latency 0.25 "${PWD}" &
    WATCH_PID=$!

    # Trap SIGINT to gracefully stop the background process when the script is interrupted
    trap 'kill ${WATCH_PID}; exit' SIGINT
}

stop_dir_watcher() {
    if [[ ${WATCH_PID} != "" ]]; then
        echo -e "Stopping dir watcher...\n"
        kill -SIGTERM ${WATCH_PID}
    else
        echo -e "Dir watcher is not running\n"
    fi
}

# Function to start to serve in the background
start_process() {
    # FIXME:This would report al the file changes, must parse and filter out waht we are really interested in
    #start_dir_watcher

    echo -e "\nStarting to serve...\n"

    reset_watcher

    rm -Rf _site
    rm -Rf _data/links
    rm -Rf .jekyll-cache

    # TODO: We need a pre (double) build as the _data/links folder currently generated from th
    bundle exec jekyll build
    bundle exec jekyll serve ${ALL_PARAMS} &
    PROC_PID=$!

    echo -e "\n\n\n"
}

stop_process() {
    stop_dir_watcher

    echo -e "\nStopping to serve...\n"
    kill -SIGTERM ${PROC_PID}
    wait ${PROC_PID}  >/dev/null 2>&1  # Wait for the process to terminate
    rm -f "${REF_FILE}"
}

check_watched_file_changed() {
    RES="$(find "$1" -newer "${REF_FILE}")"
    if [ "${RES}x" == "x" ]; then
        return 1
    else
        return 0
    fi
}

reset_watcher() {
    touch "${REF_FILE}"
}

# Function to handle file changes
handle_file_changes() {
    # Space separated list of files to watch
    FILES_TO_WATCH=("./_config.yml")

    for FILE in "${FILES_TO_WATCH[@]}"; do
        if check_watched_file_changed "${FILE}" ; then
            echo "\nFile $FILE has changed, processing."

            case "$FILE" in
                "./_config.yml")
                    echo -e ". Restarting to serve...\n"
                    stop_process
                    start_process

                    reset_watcher
                    ;;

                *)
                    echo "Unknown file: $FILE"
                    ;;
            esac



        fi
    done
}

handle_dir_changes() {
    LINE=""
    # Check for keyboard input without blocking
    read -t 1 -r LINE

    if [[ ${LINE} != "" ]]; then
        echo "\nDir $PWD has changed, processing."
        echo -e ". Regenerating ${NAV_DATA_FILE}\n"
        ./_tools/navgen ./dev-guide ./admin-guide ./doc-guide "${NAV_DATA_FILE}"
    fi
}

# Main loop
start_process

while true; do
    KEY=0
    # Check for keyboard input without blocking
    read -t 1 -n 1 KEY

    case ${KEY} in
        s)
            stop_process
            exit 0
            ;;
        r)
            stop_process
            start_process
            ;;
    esac

    handle_file_changes

    sleep 1
done
